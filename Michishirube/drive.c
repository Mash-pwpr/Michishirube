/*
==============================================================
 Name        : drive.c
 Copyright   : Copyright (C) 早稲田大学マイクロマウスクラブ
 Description : 走行関連の関数たちです．

  更新履歴
 2016/1/29		山上	コメント追加、test_drive内ms_waitとWAITを統合
 2016/2/15		山上	パルス関係のマクロを整理
==============================================================
*/
#include "global.h"

//※解説の章番号等は日本語版ユーザーマニュアルRev.00.15に準拠

/*==========================================================
		走行系関数
==========================================================*/
/*
		基本仕様として、
		基幹関数		第一引数:走行パルス数
						第二引数:停止許可フラグ

		マウスフラグ(MF)
			7Bit:ストップフラグ
			6Bit:定速フラグ
			5Bit:減速フラグ
			4Bit:加速フラグ
			3Bit:制御フラグ
			2Bit:スラロームフラグ
			1Bit:二次走行フラグ
			0Bit:予約ビット
		上位4Bitは、上位ほど優先度が高い
*/
/*----------------------------------------------------------
		上位関数
----------------------------------------------------------*/
//+++++++++++++++++++++++++++++++++++++++++++++++
//half_sectionA
//	半区画分加速しながら走行する
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void half_sectionA()
{
	MF.FLAG.CTRL = 1;										//制御を有効にする
	driveA(DR_SEC_HALF, 0);									//半区画のパルス分加速しながら走行。走行後は停止しない
	get_wall_info();										//壁情報を取得
}


//+++++++++++++++++++++++++++++++++++++++++++++++
//half_sectionD
//	半区画分減速しながら走行し停止する
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void half_sectionD()
{
	MF.FLAG.CTRL = 1;										//制御を有効にする
	driveD(DR_SEC_HALF, 1);									//半区画のパルス分減速しながら走行。走行後は停止する
	Wait;													//完全に止まるまで待機
}


//+++++++++++++++++++++++++++++++++++++++++++++++
//a_section
//	1区画分進んで停止する
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void a_section()
{
	half_sectionA();										//半区画分加速走行
	half_sectionD();										//半区画分減速走行のち停止
}


//+++++++++++++++++++++++++++++++++++++++++++++++
//a_sectionU
//	等速で1区画分進む
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void a_sectionU() {
	MF.FLAG.CTRL = 1;										//制御を有効にする
	driveU(DR_SEC_HALF*2, 0);								//1区画のパルス分等速走行。走行後は停止しない
	get_wall_info();										//壁情報を取得
}

//+++++++++++++++++++++++++++++++++++++++++++++++
//turn_R90
//	右に90度回転する
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void turn_R90(){
	MF.FLAG.CTRL = 0;										//制御を無効にする
	set_dir(TURN_R);										//右に回転するようモータの回転方向を設定
 	driveC(DR_ROT_R90, 1);									//低速で指定パルス分回転。回転後に停止する
	Wait;													//完全に停止するまで待機
	set_dir(FORWARD);										//前進するようにモータの回転方向を設定
}


//+++++++++++++++++++++++++++++++++++++++++++++++
//turn_L90
//	左に90度回転する
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void turn_L90()
{
	MF.FLAG.CTRL = 0;										//制御を無効にする
	set_dir(TURN_L);										//左に回転するようモータの回転方向を設定
	driveC(DR_ROT_L90, 1);									//定速で指定パルス分回転。回転後に停止する
	Wait;													//完全に停止するまで待機
	set_dir(FORWARD);										//前進するようにモータの回転方向を設定
}


//+++++++++++++++++++++++++++++++++++++++++++++++
//turn_180
//	180度回転する
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void turn_180()
{
	MF.FLAG.CTRL = 0;										//制御を無効にする
	set_dir(TURN_R);										//左に回転するようモータの回転方向を設定
	driveC(DR_ROT_180, 1);									//定速で指定パルス分回転。回転後に停止する
	Wait;													//完全に停止するまで待機
	set_dir(FORWARD);										//前進するようにモータの回転方向を設定
}


//+++++++++++++++++++++++++++++++++++++++++++++++
//set_position
//	機体の尻を壁に当てて場所を区画中央に合わせる
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void set_position()
{
	MF.FLAG.CTRL = 0;										//制御を無効にする
	set_dir(BACK);											//後退するようモータの回転方向を設定
	driveC(DR_CENT_BACK, 1);								//尻を当てる程度に後退。回転後に停止する
	set_dir(FORWARD);										//前進するようにモータの回転方向を設定
	driveC(DR_CENT_SET, 1);									//定速で指定パルス分回転。回転後に停止する
  	Wait;												//完全に停止するまで待機
}


//+++++++++++++++++++++++++++++++++++++++++++++++
//driveA
//	指定パルス分加速走行する
// 引数1：dist・・・走行するパルス
// 引数2：rs・・・走行後停止するか　1:する　それ以外:しない
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void driveA(uint16_t dist, unsigned char rs) {
	//====走行====
	//----走行開始----
	MF.FLAGS = 0x10 | (MF.FLAGS & 0x0F);					//減速・定速・ストップフラグを0に、加速フラグを1にする
	drive_start();											//走行開始

	//----走行----
	while((pulse_l < dist) && (pulse_r < dist));			//左右のモータが指定パルス以上進むまで待機

	//----停止許可があれば停止----
	drive_stop(rs);
}

//+++++++++++++++++++++++++++++++++++++++++++++++
//driveD
//	指定パルス分減速走行して停止する
// 引数1：dist・・・走行するパルス
// 引数2：rs・・・走行後停止するか　1:する　それ以外:しない
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void driveD(uint16_t dist, unsigned char rs) {
	//====変数宣言====
	signed int c_pulse;										//等速走行のパルス数

	//----必要パルス数の算出----
	c_pulse = dist + minindex - t_cnt_l;					//等速走行のパルス=総距離のパルス-減速しきるのに必要なパルス
															//=総距離のパルス-(現在の速度のパルス-最低のパルス数)
	if(c_pulse < 0) c_pulse = 0;							//負になったときは0にする

	//====走行====
	//----走行開始----
	MF.FLAGS = 0x00 | (MF.FLAGS & 0x0F);					//加速・減速・定速・ストップフラグを0にする
	drive_start();											//痩躯開始

	//----走行----
	while((pulse_l < c_pulse) && (pulse_r < c_pulse));		//左右のモータが定速分のパルス以上進むまで待機
	MF.FLAG.DECL = 1;										//減速フラグを1に
	while((pulse_l < dist) && (pulse_r < dist));			//左右のモータが減速分のパルス以上進むまで待機

	//----停止措置----
	drive_stop(rs);											//走行終了、停止許可があれば停止
}

//+++++++++++++++++++++++++++++++++++++++++++++++
//driveAD
//	指定パルス分加速(or等速)・減速走行して停止する
// 引数1：dist・・・走行するパルス
// 引数2：rs・・・走行後停止するか　1:する　それ以外:しない
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void driveAD(uint16_t dist, unsigned char rs)
{
	//====変数宣言====
	signed int ac_pulse;									//等・加速走行のパルス数

	//----加速走行パルス数の算出----
	ac_pulse = dist + minindex - t_cnt_l;					//加速走行のパルス=総距離のパルス-減速しきるのに必要なパルス
															//=総距離のパルス-(現在の速度のパルス-最低のパルス数)
	//====走行====
	//----走行開始----
	MF.FLAGS = 0x10 | (MF.FLAGS & 0x0F);					//減速・定速・ストップフラグを0に、加速フラグを1にする
	drive_start();											//走行開始

	//----走行----
	while((pulse_l < ac_pulse) && (pulse_r < ac_pulse));	//左右のモータが定速分のパルス以上進むまで待機
	ac_pulse = dist + minindex - t_cnt_l;					//パルスの再計算
	MF.FLAG.DECL = 1;										//減速フラグを1に
	while((pulse_l < dist) && (pulse_r < dist));			//左右のモータが減速分のパルス以上進むまで待機

	//----停止措置----
	drive_stop(rs);											//走行終了、停止許可があれば停止

}

//+++++++++++++++++++++++++++++++++++++++++++++++
//driveU
//	指定パルス分等速走行して停止する
// 引数1：dist・・・走行するパルス
// 引数2：rs・・・走行後停止するか　1:する　それ以外:しない
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void driveU(uint16_t dist, unsigned char rs)
{

	//====等速走行開始====
	MF.FLAGS = 0x00 | (MF.FLAGS & 0x0F);					//加速・減速・定速・ストップフラグを0にする
	drive_start();											//走行開始

	//====走行====
	while((pulse_l < dist) && (pulse_r < dist));			//左右のモータが減速分のパルス以上進むまで待機

	//====走行終了====
	//----停止許可があれば停止----
	drive_stop(rs);											//走行終了、停止許可があれば停止
}

//+++++++++++++++++++++++++++++++++++++++++++++++
//driveC
//	指定パルス分定速走行して停止する
// 引数1：dist・・・走行するパルス
// 引数2：rs・・・走行後停止するか　1:する　それ以外:しない
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void driveC(uint16_t dist, unsigned char rs)
{

	//====回転開始====
	MF.FLAGS = 0x40 | (MF.FLAGS & 0x0F);					//加速・減速・ストップフラグを0にし、定速フラグを1にする
	drive_start();											//走行開始

	//====回転====
	while((pulse_l < dist) && (pulse_r < dist));			//左右のモータが定速分のパルス以上進むまで待機

	drive_stop(rs);											//走行終了、停止許可があれば停止

}

//+++++++++++++++++++++++++++++++++++++++++++++++
//drive_start
//	走行を開始する
// 引数：なし
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void drive_start(void){
	pulse_l = pulse_r = 0;									//走行したパルス数の初期化
	pin_write(P54,1);
	pin_write(P55,1);
	pin_write(PA4,1);
	pin_write(PA6,1);

}

//+++++++++++++++++++++++++++++++++++++++++++++++
//drive_stop
//	走行終了し、停止許可があれば停止する
// 引数1：rs・・・走行後停止するか　1:する　それ以外:しない
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void drive_stop(unsigned char rs){
	pin_write(P54,0);
	pin_write(P55,0);
	pin_write(PA4,0);
	pin_write(PA6,0);

	//====停止処理====
	if(rs) MF.FLAG.STOP = 1;								//停止するのであればストップフラグを1に
}

//+++++++++++++++++++++++++++++++++++++++++++++++
//set_dir
//	進行方向を設定する
// 引数1：d_dir・・・どの方向に進行するか  0桁目で左、1桁目で右の方向設定
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void set_dir(unsigned char d_dir)
{
	//====左モータ====
	switch(d_dir & 0x0f){									//0~3ビット目を取り出す
		//----正回転----
		case 0x00:											//0x00の場合
			PIN_SET(MDR_CW_L, MT_FWD_L);					//左を前進方向に設定
			break;
		//----逆回転----
		case 0x01:								 			//0x01の場合
			PIN_SET(MDR_CW_L, MT_BACK_L);					//左を後進方向に設定
			break;
	}
	//====右モータ====
	switch(d_dir & 0xf0){									//4~7ビット目を取り出す
		case 0x00:											//0x00の場合
			PIN_SET(MDR_CW_R, MT_FWD_R);					//右を前進方向に設定
			break;
		case 0x10:											//0x10の場合
			PIN_SET(MDR_CW_R, MT_BACK_R);					//右を後進方向に設定
			break;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++
//test_drive
//	走行関係のテストをする
// 引数1：mode・・・モード番号を格納する変数のアドレス
// 戻り値：なし
//+++++++++++++++++++++++++++++++++++++++++++++++
void test_drive(char *mode){

	while(!RET){											//決定ボタンが押されていない間実行
		uart_printf("test_drive:\n");						//UARTで送信
		select_mode(mode);									//モード選択をさせる
		ms_wait(300);										//少し待機

		PIN_H(MDR_REF);										//励磁をONにする
		stay(DEFWAIT);										//少し待機

		switch(*mode){										//モード番号により分岐
			//----位置の調整----
			case 0:
				set_position();
				break;

			//----一区画定速走行----
			case 1:
				set_dir(FORWARD);
				driveC(DR_SEC_HALF*2, 1);
				set_dir(FORWARD);
				driveC(DR_SEC_HALF*2, 1);
				set_dir(FORWARD);
				driveC(DR_SEC_HALF*2, 1);
				set_dir(FORWARD);
				driveC(DR_SEC_HALF*2, 1);
				set_dir(FORWARD);
				driveC(DR_SEC_HALF*2, 1);
				set_dir(FORWARD);
				driveC(DR_SEC_HALF*2, 1);


				break;

			//----右90回転----
			case 2:
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				turn_R90();
				break;

			//----左90回転----
			case 3:
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				turn_L90();
				break;

			//----180回転----
			case 4:
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();
				turn_180();

				break;

			//----高速加減速8区画----
			case 7:
				minindex = MINSPEED_H;
				maxindex = MAXSPEED_H;
				stay(DEFWAIT);
				MF.FLAG.CTRL = 1;
				driveAD((DR_SEC_HALF*2) * 6, 1);
				break;

			//----探索用加減速1区画----
			case 8:
				minindex = MINSPEED_S;
				maxindex = MAXSPEED_S;
				stay(DEFWAIT);
				a_section();
				break;

			default:
				return;
		}
		PIN_L(MDR_REF);										//励磁をOFFにする
	}
}

