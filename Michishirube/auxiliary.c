/*
==============================================================
 Name        : auxiliary.c
 Copyright   : Copyright (C) 早稲田大学マイクロマウスクラブ
 Description : 補助関数たちです．労わりましょう．

 更新履歴
 2015/12/4		山上	一部コメント追加、mode_selectのLED表示部分とmodeの処理を変更
 2015/1/30		山上	一部コメント追加、表示用LEDの設定を追加
==============================================================
*/

/*ヘッダファイルの読み込み*/
#include "global.h"

//※解説の章番号等は日本語版ユーザーマニュアルRev.00.15に準拠

//+++++++++++++++++++++++++++++++++++++++++++++++
//wait
//	ms_waitは重複して使用する(以下参照)ことが出来ない
//	(動作が途中で止まる)。そのため、割り込み関数内では
//	正確な時間は測定できないがwhile文ループを用いて待機する
// 引数1：loop・・・待機するループ数
// 戻り値：無し
//+++++++++++++++++++++++++++++++++++++++++++++++
void stay(unsigned int loop){
	while(loop--);					//loop回while文を回す
}
//+++++++++++++++++++++++++++++++++++++++++++++++
//ms_wait
//	ミリ秒待機する
// 引数1：ms・・・待機時間[ミリ秒]
// 戻り値：無し
//+++++++++++++++++++++++++++++++++++++++++++++++
void ms_wait(unsigned int ms){

	uint16_t timercnt, i;
	// PDGで動作クロックを、システムクロック20MHzを32で割って分周してある
	R_PG_Timer_StartCount_CMT_U0_C0(); // カウントスタート

	for(i=0; i<ms; i++){
		R_PG_Timer_SetCounterValue_CMT_U0_C0(0); // カウント値をゼロに戻す
		do{
			R_PG_Timer_GetCounterValue_CMT_U0_C0(&timercnt); // カウント値を取得
		} while(timercnt < 624 ); // 624カウント目で1ms経ったことになる
	}

	R_PG_Timer_HaltCount_CMT_U0_C0(); // カウント終了

}

// --※ms_waitが本文と割り込み関数で重複した場合の流れ--
//	本文							割り込み関数
//	ms_wait関数を使用
//	↓
//	SysTickタイマを動作開始
//	↓
//	カウンタが一定数たまるまで待機
//	↓
//	(待機中割り込み発生)		→	ms_wait関数を使用
//								↓
//								(SysTickタイマを動作開始)
//								↓
//								カウンタが一定数たまるまで待機
//								↓
//								待機終了
//								↓
//								カウンタを止める
//								↓
//	カウンタが一定数たまるまで待機	←	(割り込み終了)
//	↓
//	(SysTickタイマが動作していないため
//	カウンタがたまらず以降待機のまま動作せず)


/*------------------------------------------------------------
		モードセレクト
------------------------------------------------------------*/
//+++++++++++++++++++++++++++++++++++++++++++++++
//select_mode
//	モードセレクトを行う
// 引数1：mode・・・モード番号を格納する変数のアドレス
// 戻り値：無し
//+++++++++++++++++++++++++++++++++++++++++++++++
void select_mode(char *mode){

	*mode = 0x00;									//変数の初期化

	//====変数初期化====
	uart_printf(" mode: 0\r");						//モードをUARTで送信

	//====モード選択処理====
	while(!RET){									//決定ボタンが押されるまでループ
		//----インクリメント----
		if(INC){									//増加ボタンが押された場合
			*mode += 1;								//モード番号をインクリメント
			*mode = (*mode + 16) % 16;				//0から16内に抑える
			uart_printf(" mode:%2d\r", *mode);		//モード番号をUARTで送信
			ms_wait(250);							//少し待機
		}
		//----デクリメント----
		else if(DEC){								//減少ボタンが押された場合
			*mode -= 1;								//モード番号をデクリメント
			*mode = (*mode + 16) % 16;				//0から16内に抑える
			uart_printf(" mode:%2d\r", *mode);		//モード番号をUARTで送信
			ms_wait(250);							//少し待機
		}

		//LEDで現在の値を表示
		pins_write(DISP_LEDS, *mode, 4);			//LEDがActiveLowの場合
	}
}

void timer_start(){
	R_PG_Timer_StartCount_MTU_U0_C1();
	R_PG_Timer_StartCount_MTU_U0_C2();
	R_PG_Timer_StartCount_MTU_U0_C3();
	R_PG_Timer_StartCount_MTU_U0_C4();

	R_PG_Timer_StartCount_CMT_U0_C1();

}
	
